tokens {
	id <- (alpha (alpha | digit)* - kwd) | (char1 char2 - `//`) char2* | char1;
	int <- digit+;
	float <- digit* `.` digit+;
	string <- `'` (unicode_any - `'`)* `'`;

	kwd <= `func` | `if` | `else` | `elif` | `ret` | `mut` | `type` | `raw` | `import` | `final` | `let`;

	ws <= (` ` | `\t` | `\r` | `\f` | `\n`);
	digit <= `0`..`9`;
	alpha <= `a`..`z` | `A`..`Z` | `_`;
	char1 <= unicode_any - (`'` | ws | langstruc | digit | `\`` | operator | alpha | digit);
	char2 <= unicode_any - (`'` | ws | langstruc | digit | `\`` | alpha | digit);

	langstruc <= `[` | `]` | `,` | `;` | `.` | `:` | `{` | `}`;
	operator <= `=`;

	cpp_sep <= `\`\`\``;
	cpp_block <- cpp_sep (unicode_any - `\``)* cpp_sep;

	top <= operator | cpp_block | kwd | id | int | float | string | langstruc;
}

lexer {
	main { body }

	mode body {
		`//` => { push comment_single; }
		top => { emit; }
		ws => { pass; }
		eof => { pop; }
	}

	mode comment_single {
		`\n` => { pop_extract; }
		eof => { pop_extract; }
		_ => { pass; }
	}
}

parser {
	main { Module, Decl, Block, Stmt, Expr }

	prec {
		Signature.Subtype assoc_left;
		Signature.Template;
		Signature.Type_;

		Expr.Assign assoc_right;
		Expr.Oper;
		Expr.Dot assoc_left;
		Expr.Id Expr.Lit.Integer Expr.Lit.Float Expr.Lit.String Expr.Lit.Array Expr.Paren;
	}

	prop { name_strict; }

	Module <- decls:#T2[Decl::eps];

	Signature.Type_ <- name:id;
	Signature.Template <- type:Signature `{` subtypes:#L[Signature[pr=*]::`,`:?] `}`;
	Signature.Subtype <- object:Signature `.` type:Signature;

	Qualifier.Mut <- `mut` _;
	Qualifier.Raw <- `raw` _;
	Qualifier.Final <- `final` _;

	Decl.Var <- `let` _ name:id _ `:` _ quals:Qualifier* type:Signature? assign:(_ `=` _ value:Expr)? `;`;
	Decl.Func <- `let` _ name:id _ `:` _ quals:Qualifier* `func` `[` params:#L[ParamDecl::`,`:?] `]` return_type:Signature? _ block:Block;

	ParamDecl.Var <- name:id _ `:` _ quals:Qualifier* type:Signature assign:(_ `=` _ value:Expr)?;
	ParamDecl.Func <- name:id _ `:` _ quals:Qualifier* `func` `[` params:#L[ParamDecl::`,`:?] `]` return_type:Signature;

	KeyPair <= key:(expr:Expr[pr=*] _ `:` _)? value:Expr[pr=*];

	Expr.Id <- name:id;
	Expr.Lit.Integer <- value:int;
	Expr.Lit.Float <- value:float;
	Expr.Lit.String <- value:string;
	Expr.Lit.Array <- `[` items:#L[KeyPair::`,`_::] `]`;
	Expr.Assign <- left:Expr _ `=` _ right:Expr;
	Expr.Oper <- params:#L[Expr::++eps _];
	Expr.Paren <- `[` expr:Expr[pr=*] `]`;
	Expr.Dot <- left:Expr `.` right:Expr;

	Block <- `[` stmts:#B[Stmt::eps] `]`;

	Stmt.Expr <- e:Expr `;`;
	Stmt.Block <- `.` block:Block;
	Stmt.Decl <- decl:Decl;
}

test {
	`let T : x{a}.y;` <- Decl;
	`let T : x.y{a};` <- Decl;
	`let T : x{a}.y{b};` <- Decl;
	`let x : int = y = 3;` <- Decl;
	`let x :  = [not true] or false;` <- Decl;
	`['a' = 1, 'b' = 2, ]` <- Expr;
	`['a' : 1, 'b' : 2, 'c', ]` <- Expr;
}
