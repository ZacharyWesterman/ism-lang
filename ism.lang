tokens {
	id <- (alpha (alpha | digit)* - kwd) | (char1 char2 - `//`) char2* | char1;
	int <- digit+;
	float <- digit* `.` digit+;
	string <- `'` (unicode_any - `'`)* `'`;

	kwd <= `func` | `if` | `else` | `elif` | `ret` | `mut` | `type` | `raw` | `import` | `final`;

	ws <= (` ` | `\t` | `\r` | `\f` | `\n`);
	digit <= `0`..`9`;
	alpha <= `a`..`z` | `A`..`Z` | `_`;
	char1 <= unicode_any - (`'` | ws | langstruc | digit | `\`` | operator | alpha | digit);
	char2 <= unicode_any - (`'` | ws | langstruc | digit | `\`` | alpha | digit);

	langstruc <= `[` | `]` | `,` | `;` | `.` | `:` | `{` | `}`;
	operator <= `=`;

	cpp_sep <= `\`\`\``;
	cpp_block <- cpp_sep (unicode_any - `\``)* cpp_sep;

	top <= operator | cpp_block | kwd | id | int | float | string | langstruc;
}

lexer {
	main { body }

	mode body {
		`//` => { push comment_single; }
		top => { emit; }
		ws => { pass; }
		eof => { pop; }
	}

	mode comment_single {
		`\n` => { pop_extract; }
		eof => { pop_extract; }
		_ => { pass; }
	}
}

parser {
	main { Program }

	prec {
		Expr.BinaryOp assoc_left;
		Expr.Assign assoc_left;
		Expr.Literal Expr.Id Expr.Paren;
		Expr.FuncCall postfix;
		Expr.CPP;
	}

	prop { name_strict; }

	Program <- stmts:Stmt+;

	Stmt.Decl <- ~x:Decl;
	Stmt.Call <- ~x:Expr[F] `;`;
	Stmt.Assign <- ~x:Expr[A] `;`;
	Stmt.CPP <- x:Expr[C];
	Stmt.Null <- `;`;
	Stmt.Cond <- begin:Cond[B] middle:Cond[M]* end:Cond[E]?;
	Stmt.Return <- `ret` _ x:Expr? `;`;
	Stmt.Import <- israw:`raw`? _ `import` _ module:Module `;`;

	Module.Local <- `.` module_path:#L[id::`.`];
	Module.Global <- module_path:#L[id::`.`];

	//Conditional statements
	Cond.If[B] <- `if` _ `[` expr:Expr[pr=*] `]` _ scope:Scope;
	Cond.Elif[M] <- `elif` _ `[` expr:Expr[pr=*] `]` _ scope:Scope;
	Cond.Else[E] <- `else` _ scope:Scope;

	Scope <- `[` stmts:Stmt[pr=*]* `]`;

	Literal.Int_ <- val:int;
	Literal.Float_ <- val:float;
	Literal.String <- val:#L[string::+_];

	Expr.FuncCall[F] <- name:id `[` params:#L[Expr[pr=*]::`,`:?] `]`;
	Expr.Id[I] <- name:id;
	Expr.Literal <- val:Literal;
	Expr.Assign[A] <- name:id _ `=` _ y:Expr;
	Expr.Paren <- `[` elems:#L[Expr[pr=*]::`,`:?] `]`;
	Expr.BinaryOp <- x:Expr _ op:id _ y:Expr;
	Expr.CPP[C] <- cpp:cpp_block;

	DataType.Var[V] <- type:#L[id::`.`];
	DataType.Templated[V] <- type:DataType[V] `{` subtype:DataType `}`;

	Decl.Var <- name:id _ `:` _ sig:Signature[V] _ assgt:(`=` _ expr:Expr[pr=*])? `;`;
	Decl.Func <- name:id _ `:` sig:Signature[F] _ scope:Scope;

	ParamDecl <- name:id _ `:` sig:Signature;
	Quals <- isfinal:`final`? _ israw:`raw`? _ ismut:`mut`?;

	Signature.Var[V] <- qualifiers:Quals _ type:DataType;
	Signature.Func[F] <- qualifiers:Quals _ `func` `[` params:#L[ParamDecl::`,`:?] `]` _ return_type:DataType;
	Signature.Type_[F] <- qualifiers:Quals _ `type` templ:(`{` params:#L[ParamDecl::`,`:?] `}`)?;

}
