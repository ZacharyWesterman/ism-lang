tokens {
	id <- (alpha (alpha | digit)* - kwd) | (char1 char2 - `//`) char2* | char1;
	int <- digit+;
	float <- digit* `.` digit+;
	string <- `'` (unicode_any - `'`)* `'`;

	kwd <= `func` | `if` | `else` | `elif` | `ret` | `mut` | `type` | `raw` | `import` | `final`;

	ws <= (` ` | `\t` | `\r` | `\f` | `\n`);
	digit <= `0`..`9`;
	alpha <= `a`..`z` | `A`..`Z` | `_`;
	char1 <= unicode_any - (`'` | ws | langstruc | digit | `\`` | operator | alpha | digit);
	char2 <= unicode_any - (`'` | ws | langstruc | digit | `\`` | alpha | digit);

	langstruc <= `[` | `]` | `,` | `;` | `.` | `:` | `{` | `}`;
	operator <= `=`;

	cpp_sep <= `\`\`\``;
	cpp_block <- cpp_sep (unicode_any - `\``)* cpp_sep;

	top <= operator | cpp_block | kwd | id | int | float | string | langstruc;
}

lexer {
	main { body }

	mode body {
		`//` => { push comment_single; }
		top => { emit; }
		ws => { pass; }
		eof => { pop; }
	}

	mode comment_single {
		`\n` => { pop_extract; }
		eof => { pop_extract; }
		_ => { pass; }
	}
}

parser {
	main { Decl }

	prec {
		Signature.Subtype assoc_left;
		Signature.Template;
		Signature.Type_;
	}

	prop { name_strict; }

	Signature.Type_ <- name:id;
	Signature.Template <- type:Signature `{` subtypes:#L[Signature[pr=*]::`,`:?] `}`;
	Signature.Subtype <- object:Signature `.` type:Signature;

	Decl.Var <- name:id _ `:` _ type:Signature `;`;

}

test {
	`T : x{a}.y;` <- Decl;
	`T : x.y{a};` <- Decl;
	`T : x{a}.y{b};` <- Decl;
}
