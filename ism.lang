tokens {
	id <- (alpha (alpha | digit)* - kwd) | (char1 char1 - `//`) char1* | char1;
	int <- digit+;
	float <- digit* `.` digit+;
	string <- `'` (unicode_any - `'`)* `'`;

	kwd <=
		  `if`     | `else`   | `elif`   | `do`       | `for`   | `while`
		| `let`    | `mut`    | `prefix` | `postfix`  | `infix` | `type`
		| `return` | `import` | `final`  | `continue` | `break` | `volatile`
		| `yield`  | `async`  | `await`  | `thread`   | `of`    | `inherit`
		| `use`    | `try`    | `catch`  | `finally`  | `throw` | `override`
		| `in`     | `true`   | `false`  | `null`     | `as`    | `with`
		| `trait`  | `fn`;

	ws <= (` ` | `\t` | `\r` | `\f`);
	digit <= `0`..`9`;
	alpha <= `a`..`z` | `A`..`Z` | `_`;
	char1 <= unicode_any - (`'` | ws | langstruc | digit | `\`` | operator | alpha | digit | endline);

	langstruc <= `[` | `]` | `,` | `.` | `:` | `{` | `}` | `(` | `)` | `=>` | `|` | `...` | `@`;
	operator <= `=`;
	endline <= `\n` | `;`;

	c_block <- `\`\`\`` (unicode_any)* `\`\`\``;

	top <= operator | c_block | kwd | id | int | float | string | langstruc | endline;
}

lexer {
	main { body }

	mode body {
		`//` => { push comment_single; }
		top => { emit; }
		ws => { pass; }
		eof => { pop; }
	}

	mode comment_single {
		`\n` => { pop_extract; }
		eof => { pop_extract; }
		_ => { pass; }
	}
}

parser {
	main { TopLevel, Expr }

	prec {
		Expr.Group;
		Expr.Ternary assoc_right;
		Expr.In assoc_left;
		Expr.ListCompKey Expr.ListCompNoKey assoc_right;
		Expr.Lambda Expr.Function;
		Expr.Id Expr.Literal Expr.Paren Expr.Array Expr.Dict;
	}

	prop { name_strict; }

	TopLevel <- expr:Expr;

	Literal.Integer <- value:int;
	Literal.Float <- value:float;
	Literal.String <- value:string;
	Literal.C <- code:c_block;
	Literal.Boolean <- True:`true` | False:`false`;

	KeyPair <- key:Expr `:` _ value:Expr;

	TypeDecl.Single <- name:id subtypes:(`[` types:#L[TypeDecl::`,` _ :?] `]`)?;
	TypeDecl.Function <- `(` params:#L[TypeDecl::`,`:?] `)` returns:(`:` _ decl:TypeDecl)?;
	FuncParam <- name:id type:(`:` _ decl:TypeDecl)?;
	FuncSignature <- `fn` `(` params:#L[FuncParam::`,`_:?] `)` returns:(`:` _ decl:TypeDecl)?;

	Expr.Group <- items:#L[Expr::++ _];
	Expr.Id <- name:id;
	Expr.Literal <- value:Literal;
	Expr.Ternary <- true_expr:Expr _ `if` _ condition:Expr _ `else` _ false_expr:Expr;
	Expr.Paren <- `(` items:#L[Expr[pr=*]::+`,`:?] `)`;
	Expr.Array <- `[` items:#L[Expr[pr=*]::+`,`:?] `]`;
	Expr.Dict <- `{` items:#L[KeyPair::`,`_:?] `}`;
	Expr.In <- item:Expr _ `in` _ list:Expr;
	Expr.ListCompNoKey <- item:Expr _ `for` _ value:id _ `in` _ list:Expr condition:(_ `with` _ expr:Expr)?;
	Expr.ListCompKey <- item:Expr _ `for` _ key:id `,` _ value:id _ `in` _ list:Expr condition:(_ `with` _ expr:Expr)?;
	Expr.Lambda <- signature:FuncSignature _ `=>` _ expr:Expr;
	Expr.Function <- signature:FuncSignature _ e:#L[`\n`::eps] `{` `}`;
}

test {
	`a + 3` <- Expr;
	`1 if 3 else 0` <- Expr;
	`{}` <- Expr;
	`{a: (1), b: 3}` <- Expr;
	`[1,2,3]` <- Expr;
	`(1,2,3)` <- Expr;
	`true or false` <- Expr;
	`true if item in list else false` <- Expr;
	`i for i in list with x < 4` <- Expr;
	`key + ':' + value for key, value in {a: b, c: d}` <- Expr;
	`fn(this, text: str) => text + '!'` <- Expr;
}
