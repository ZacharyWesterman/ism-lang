tokens {
	id <- (alpha (alpha | digit)* - kwd) | (char1 char2 - `//`) char2* | char1;
	int <- digit+;
	float <- digit* `.` digit+;
	string <- `'` (unicode_any - `'`)* `'`;

	kwd <= `func` | `if` | `do` | `else` | `elif` | `return` | `mut` | `type` | `import` | `final` | `let` | `of` | `in` | `for` | `while` | `break` | `next` | `prefix` | `postfix` | `infix`;

	ws <= (` ` | `\t` | `\r` | `\f`);
	digit <= `0`..`9`;
	alpha <= `a`..`z` | `A`..`Z` | `_`;
	char1 <= unicode_any - (`'` | ws | langstruc | digit | `\`` | operator | alpha | digit | endline);
	char2 <= unicode_any - (`'` | ws | langstruc | digit | `\`` | alpha | digit | endline);

	langstruc <= `[` | `]` | `,` | `.` | `:` | `{` | `}` | `(` | `)`;
	operator <= `=`;
	endline <= `\n` | `;`;

	cpp_sep <= `\`\`\``;
	cpp_block <- cpp_sep (unicode_any - `\``)* cpp_sep;

	top <= operator | cpp_block | kwd | id | int | float | string | langstruc | endline;
}

lexer {
	main { body }

	mode body {
		`//` => { push comment_single; }
		top => { emit; }
		ws => { pass; }
		eof => { pop; }
	}

	mode comment_single {
		`\n` => { pop_extract; }
		eof => { pop_extract; }
		_ => { pass; }
	}
}

parser {
	main { TopLevel, Expr }

	prec {
		Expr.Group;
		Expr.Ternary assoc_right;
		Expr.Id Expr.Literal Expr.Paren Expr.Array Expr.Dict;
	}

	prop { name_strict; }

	TopLevel <- expr:Expr;

	Literal.Integer <- value:int;
	Literal.Float <- value:float;
	Literal.String <- value:string;

	KeyPair <- key:Expr `:` _ value:Expr;

	Expr.Group <- items:#L[Expr::++ _];
	Expr.Id <- name:id;
	Expr.Literal <- value:Literal;
	Expr.Ternary <- true_expr:Expr _ `if` _ condition:Expr _ `else` _ false_expr:Expr;
	Expr.Paren <- `(` items:#L[Expr[pr=*]::+`,`:?] `)`;
	Expr.Array <- `[` items:#L[Expr[pr=*]::+`,`:?] `]`;
	Expr.Dict <- `{` items:#L[KeyPair::`,`_:?] `}`;
}

test {
	`a + 3` <- Expr;
	`1 if 3 else 0` <- Expr;
	`{}` <- Expr;
	`{a: (1), b: 3}` <- Expr;
	`[1,2,3]` <- Expr;
	`(1,2,3)` <- Expr;
}
