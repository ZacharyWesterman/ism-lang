tokens {
	id <- (alpha (alpha | digit)* - kwd) | (char1 char2 - `//`) char2* | char1;
	int <- digit+;
	float <- digit* `.` digit+;
	string <- `'` (unicode_any - `'`)* `'`;

	datatypes <= `var` | `bool` | `int` | `float` | `string` | `true` | `false` | `list`;
	kwd <= datatypes | `func` | `if` | `else` | `elif` | `ret` | `mut` | `type` | `raw`;

	ws <= (` ` | `\t` | `\r` | `\f` | `\n`);
	digit <= `0`..`9`;
	alpha <= `a`..`z` | `A`..`Z` | `_`;
	char1 <= unicode_any - (`'` | ws | langstruc | digit | `\`` | operator | alpha | digit);
	char2 <= unicode_any - (`'` | ws | langstruc | digit | `\`` | alpha | digit);

	langstruc <= `[` | `]` | `,` | `;` | `.`;
	operator <= `=`;

	cpp_sep <= `\`\`\``;
	cpp_block <- cpp_sep `cpp` (unicode_any - `\``)* cpp_sep;

	top <= operator | cpp_block | kwd | id | int | float | string | langstruc;
}

lexer {
	main { body }

	mode body {
		`//` => { push comment_single; }
		top => { emit; }
		ws => { pass; }
		eof => { pop; }
	}

	mode comment_single {
		`\n` => { pop_extract; }
		eof => { pop_extract; }
		_ => { pass; }
	}
}

parser {
	main { Program }

	prec {
		Expr.BinaryOp assoc_left;
		Expr.Assign assoc_left;
		Expr.Literal Expr.Id Expr.Paren;
		Expr.FuncCall prefix;
		Expr.CPP;
	}

	prop { name_strict; }

	Program <- stmts:Stmt+;

	Stmt.Decl <- x:Decl;
	Stmt.Expr <- x:Expr `;`;
	Stmt.Null <- `;`;
	Stmt.Cond <- begin:Cond[B] middle:Cond[M]* end:Cond[E]?;
	Stmt.Return <- `ret` _ x:Expr? `;`;
	Stmt.Typedef <- `type` _ name:id `[` members:Decl* `]`;

	//Conditional statements
	Cond.If[B] <- `if` _ `[` expr:Expr[pr=*] `]` _ scope:Scope;
	Cond.Elif[M] <- `elif` _ `[` expr:Expr[pr=*] `]` _ scope:Scope;
	Cond.Else[E] <- `else` _ scope:Scope;

	Scope <- `[` stmts:Stmt[pr=*]* `]`;

	Literal.Int_ <- val:int;
	Literal.Float_ <- val:float;
	Literal.String <- val:#L[string::+_];
	Literal.Boolean <- val:(TRUE:`true` | FALSE:`false`);

	Expr.FuncCall <- name:id `[` params:#L[Expr[pr=*]::`,`:?] `]`;
	Expr.Id[I] <- name:id;
	Expr.Literal <- val:Literal;
	Expr.Assign[A] <- x:Expr[I] _ `=` _ y:Expr;
	Expr.Paren <- `[` elems:#L[Expr[pr=*]::`,`:?] `]`;
	Expr.BinaryOp <- x:Expr _ op:id _ y:Expr;
	Expr.CPP <- cpp:cpp_block;

	DataType.Literal <- type:(BOOL:`bool` | INT:`int` | FLOAT:`float` | STRING:`string`);
	DataType.Var <- `var` type:(`[` type:DataType `]`)?;
	DataType.List <- `list` _ type:DataType;

	Signature.Var[V] <- ismut:`mut`? _ ~type:DataType _ name:id _ assgt:(`=` _ expr:Expr[pr=*])?;
	Signature.Func[F] <- ismut:`mut`? _ `func` `[` params:#L[Signature[pr=*]::`,`:?] `]` _ name:id;
	Signature.RawFunc[F] <- `raw` _ `func` `[` params:#L[Signature[pr=*]::`,`:?] `]` _ name:id;

	Decl.Var <- type:Signature[V] `;`;
	Decl.ExprFunc <- type:Signature[F] _ `=` _ expr:Expr[pr=*] `;`;
	Decl.Func <- type:Signature[F] _ scope:Scope;
}

test {
	`1 + 1;` <<>>;
	`func[] x []` <<>>;
	`foo[x];` <<>>;
	`foo[1];` <<>>;
	`[123];` <<>>;
	`func[] x = [];` <<>>;
	`func[float a, int b] x []` <<>>;
	`[a = 1, b = 2];` <<>>;
	`x = [ test = 1.23 ];` <<>>;
	`var env = [USER = '', HOSTNAME = ''];` <<>>;
	`var a = 1; var b = 2;` <<>>;
	`func[var a = 1] x []` <<>>;
	`\`\`\`cpp test\`\`\`;` <<>>;
	`if [1] []` <<>>;
}
